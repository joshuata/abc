An expression is side-effect-free if it does not contain a function
call or any subexpression which can modify the state (such as an
assignment).  

A expression e is in normal form if it has one of the following
forms:

1. e is an assignment expression e1=e2, for side-effect-free
expressions e1 and e2, and e1 is a lhs expression

2. e is of the form e1=f(arg0,...), for side-effect-free
expressions e1, f, arg0, .... (function call with left-hand-side)

3. e is of the form f(arg0,...), for side-effect-free
expressions f, arg0, ... (function call with no left-hand-side)

4. ditto last two with $spawn inserted before the call

A statement is in normal form if:
 - if it is an expression statement wrapping e, then
   e is in normal form
 - for other kinds of statements: all its
   member expressions are side-effect-free and all its
   member statements are in normal form.

--

A SEFTriple is an ordered triple [b|e|a] where b and a are some sequences
of statements in normal form and e is an expression in normal form.

There is a sense in which two triples are equivalent.  Basically think
of starting in some arbitrary state s, then executing the statements in b,
then evaluating e and shorting the result in V, then, then executing the
statements in a.  Call the resulting state s'.  Hence the result of executing
a triple from s in a pair (V,s').  If for any s, the result of executing t
equals the result of executing t' then t and t' are equivalent.  (Modulo
the temporary variables which you can ignore after execution completes.)

--

The following operations take an SEFTriple t=[b|e|a] and return an
equivalent SEFTriple.

shift([b|e|a]) = [b,tmp=e,a|tmp|].
// introduces new temporary variable tmp to hold result
// of evaluating e.  Note that in the resulting triple,
// the expression is sef (since it is just a variable),
// and the after clause is empty.

makesef(t) = t           if sef(e)
makesef(t) = shift(t)    otherwise.
// does the shift if e is not sef.
// guarantees that in the result, expression will be sef.

emptyafter(t) = t          if empty(a)
emptyafter(t) = shift(t)   otherwise
// does shift if a is not empty.  Always guarantees that
// the resulting after clause will be empty

purify(t) = t          if empty(a) and sef(e)
purify(t) = shift(t)   otherwise
// does the shift if a is not empty or e is not sef.
// guarantees expression part of result is s.e.f. and a is empty.

--

Define 

  translate:      Expr -> SEFTriple 
  lhstranslate: LHSExpr-> SEFTriple
  
Expr is all expressions (not just sef).
LHSExpr is all left-hand-side expressions.

The result of lhstranslate actually always has from [b|e|] where
e is an LHS expression and is side-effect-free, e.g.,
x or a[i][j].v.

--

Definition of lhstranslate by cases:

Variable x:
lhstranslate(x) = translate(x) = [|x|].

Index expression lhs[expr]:
Let lhstranslate(lhs) = [b1|e1|].
Let purify(translate(expr)) = [b2|e2|].
lhstranslate(lhs[expr]) = [b1,b2|e1[e2]|].

Pointer dereferences *(expr):
Let purify(translate(expr))=[b|e|].
translate(*(expr))=[b|*e|].

Field: expr.n:
Let lhstranslate(expr)=[b|e|].
translate(expr.n) = [b|e.n|].

--

Definition of translate by cases:

lhs++:
Let lhstranslate(lhs)=[b|e|].
translate(lhs++)=[b|e|e=e+1].

++lhs:
Let lhstranslate(lhs)=[b|e|].
translate(++lhs)=[b,e=e+1|e|]

lhs=rhs:
Let lhstranslate(lhs)=[b1|e1|], emptyAfter(translate(rhs))=[b2|e2|].
translate(lhs=rhs) = [b1,b2,e1=e2|e1|]

*expr:
Let makesef(translate(expr))=[b|e|a].
translate(*expr)=[b|*e|a].

expr1+expr2:
Let makesef(translate(expr1))=[b1|e1|a1],
makesef(translate(expr2))=[b2|e2|a2].
translate(expr1+expr2)=[b1,b2|e1+e2|a1,a2].
Replace + with any side-effect-free binary operator. Subscription too?

-expr:
Let makesef(translate(expr))=[b1|e1|a1].
translate(-expr)=[b1|-e1|a1].
Replace - with any side-effect-free unary operator.

func(arg1, arg2, ...):
Let purify(func)=[b0|f|].
Let purify(arg1)=[b1|e1|], ...
translate(func(arg1, ...)) = [b1,b2,...|f(e1,e2,...)|].

lhs+=rhs:
evaluations are unsequences but the assignment happens after
they complete.
Let lhstranslate(lhs)=[b1|e1|].
Let purify(translate(rhs))=[b2|e2|].
translate(lhs+=rhs) = [b1,b2,e1=e1+e2|e1|].

expr1,expr2:
sequence point at ,
let translate(expr1)   = [b1|e1|a1].
let translate(expr2)   = [b2|e2|a2].
translate(expr1,expr2) = [b1,e1^,a1,b2|e2|a2].
Here e1^ means: omit this if e1 is s.e.f., else make it the expression
statement e1;.

c ? expr1 : expr2:
sequence point at ?
purify(translate(c))   = [b0|e0|]
sef(translate(expr1))  = [b1|e1|a1]
sef(translate(expr2))  = [b2|e2|a2]

translate(c?expr1:expr2) :

if b1, a1, b2, a2 are all empty:
   [b0 | e0?e1:e2 | ]
otherwise:
   [ b0, decl tmp,
     if (e0) { b1; tmp=e1; a1 } else { b2; tmp=e2; a2 }
   | tmp
   |
   ]



-------------------------

Statements

expr;
let translate(expr)=[b|e|a].
trans(expr;) = b; e^; a;

while (expr) stmt
let purify(expr)

for (e1; e2; e3) stmt
purify all...convert to while

return expr;
let emptyafter(translate(expr))=[b|e|].
tran(return expr;) = b; return e;

switch (expr) {...}

choose {S1; ...}

atomic {S}

when (expr) stmt

if (cond) s1 else s2
let purify(cond)=[b|e|]
trans(if (cond) s1 else s2) =
  b; if (e) trans(s1) else trans(s2)
  
